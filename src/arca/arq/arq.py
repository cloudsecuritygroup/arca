##
## Copyright 2022 Zachary Espiritu
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

from __future__ import annotations

from .table import Table
from .domain import Domain
from .range_query import RangeQuery
from .range_aggregate_scheme import RangeAggregateScheme
from .range_aggregate_querier import RangeAggregateQuerier, ResolveDone, ResolveContinue

from ..ste.eds import EDS

from typing import Generic, List, TypeVar, Union
from dataclasses import dataclass
from fractions import Fraction
from decimal import Decimal


@dataclass(frozen=True)
class QueryDone:
    __slots__ = ["aggregate"]
    aggregate: int


@dataclass(frozen=True)
class QueryContinue:
    __slots__ = ["search_tokens"]
    search_tokens: List[bytes]


AggregateSchemeOutputType = TypeVar("AggregateSchemeOutputType")
EdsType = TypeVar("EdsType")
TokenInputType = TypeVar("TokenInputType")
ResolveOutputType = TypeVar("ResolveOutputType")


@dataclass(frozen=True)
class ARQ(
    Generic[AggregateSchemeOutputType, EdsType, TokenInputType, ResolveOutputType]
):
    """
    An implementation of the ARQ framework from [EMT22].
    """

    __slots__ = ["eds_scheme", "aggregate_scheme"]
    eds_scheme: EDS[
        bytes, AggregateSchemeOutputType, EdsType, TokenInputType, ResolveOutputType
    ]
    aggregate_scheme: RangeAggregateScheme[
        AggregateSchemeOutputType, TokenInputType, ResolveOutputType
    ]

    def generate_key(self) -> bytes:
        """
        Generates a key for use in :func:`setup`.

        :return: a key
        """
        return self.eds_scheme.generate_key()

    def setup(self, key: bytes, table: Table) -> bytes:
        """
        Creates a new encrypted range aggregate index over the given
        :class:`Table` with the given :paramref:`key`.

        :param key: the key to encrypt with
        :param table: the :class:`Table` to compute the encrypted index over
        :return: the serialized encrypted index
        """
        ds = self.aggregate_scheme.setup(table)
        eds_serialized = self.eds_scheme.encrypt(key, ds)
        return eds_serialized

    def load_eds(self, eds_serialized: bytes) -> EdsType:
        """
        Deserializes the given encrypted data structure that was previously
        generated by :func:`setup`.

        :param eds_serialized: the serialized eds to load, as generated by
            :func:`setup`
        :return: the deserialized encrypted data structure
        """
        return self.eds_scheme.load_eds(eds_serialized)

    def query_server(self, search_tokens: List[bytes], eds: EdsType) -> List[bytes]:
        """
        The portion of the query protocol that occurs on the server.
        """
        cts: List[bytes] = list()
        for stk in search_tokens:
            ct = self.eds_scheme.query(stk, eds)
            if ct is not None:
                cts.append(ct)
        return cts

    def query(
        self, key: bytes, domain: Domain, initial_query: RangeQuery, eds: EdsType
    ) -> Union[int, float, Fraction, Decimal]:
        """
        Queries the given encrypted data structure with the given query.
        """
        querier = self.aggregate_scheme.generate_querier(
            domain=domain, query=initial_query
        )
        ds_subqueries = querier.query()
        while len(ds_subqueries) > 0:
            stks: List[bytes] = [
                self.eds_scheme.token(key, ds_subquery) for ds_subquery in ds_subqueries
            ]

            # TODO(zespirit): Move out to server
            cts = self.query_server(stks, eds)

            responses: List[ResolveOutputType] = [
                self.eds_scheme.resolve(key, ct) for ct in cts
            ]

            result = querier.resolve(responses)
            if isinstance(result, ResolveDone):
                return result.aggregate
            elif isinstance(result, ResolveContinue):
                ds_subqueries = result.subqueries

        raise BaseException("something bad")

    def generate_querier(
        self, key: bytes, domain: Domain, query: RangeQuery
    ) -> ARQQuerier[
        AggregateSchemeOutputType,
        EdsType,
        TokenInputType,
        ResolveOutputType,
    ]:
        aggregate_scheme_querier: RangeAggregateQuerier[
            TokenInputType, ResolveOutputType
        ] = self.aggregate_scheme.generate_querier(domain=domain, query=query)
        return ARQQuerier(
            key=key,
            eds_scheme=self.eds_scheme,
            aggregate_scheme_querier=aggregate_scheme_querier,
        )


QuerierAggregateSchemeOutputType = TypeVar("QuerierAggregateSchemeOutputType")
QuerierEdsType = TypeVar("QuerierEdsType")
QuerierTokenInputType = TypeVar("QuerierTokenInputType")
QuerierResolveOutputType = TypeVar("QuerierResolveOutputType")


class ARQQuerier(
    Generic[
        QuerierAggregateSchemeOutputType,
        QuerierEdsType,
        QuerierTokenInputType,
        QuerierResolveOutputType,
    ]
):
    __slots__ = ["eds_scheme", "aggregate_scheme_querier", "key"]

    def __init__(
        self,
        eds_scheme: EDS[
            bytes,
            QuerierAggregateSchemeOutputType,
            QuerierEdsType,
            QuerierTokenInputType,
            QuerierResolveOutputType,
        ],
        aggregate_scheme_querier: RangeAggregateQuerier[
            QuerierTokenInputType, QuerierResolveOutputType
        ],
        key: bytes,
    ):
        self.eds_scheme = eds_scheme
        self.aggregate_scheme_querier = aggregate_scheme_querier
        self.key = key

    def query(self) -> List[QuerierTokenInputType]:
        subqueries = self.aggregate_scheme_querier.query()
        return subqueries

    def token(self, subqueries: List[QuerierTokenInputType]) -> List[bytes]:
        stks: List[bytes] = [
            self.eds_scheme.token(self.key, subquery) for subquery in subqueries
        ]
        return stks

    def resolve(
        self, cts: List[bytes]
    ) -> Union[ResolveDone, ResolveContinue[QuerierTokenInputType]]:
        responses: List[QuerierResolveOutputType] = [
            self.eds_scheme.resolve(self.key, ct) for ct in cts
        ]
        return self.aggregate_scheme_querier.resolve(responses)
